# Coding Exercise Post-Mortem

## Design Decisions
### Doing stats calculations in stats.py or the API
I considered just doing all the calculations in the in the Django App/API itself, then just using stats.py to collect the data since the instructions didn't specify how to do it.  If this was a full production app, I would definitely put it all behind the API with authentication.  Since it wasn't full production, I just decided to do most of the calculations in stats.py, adding a few helpers to the API.

### Determining how to calculate words/sentence and most frequent word
I was debating about writing my own simple routine to determine this vs using an NLP library.  I haven't done much with NLP, but I know they already have most of the various edge cases figured out.  Having used TextBlob once or twice previously, I decided to use that.  The only real issue I ran into with implementing this is that the library requires you to download a language pack.  TextBlob wants you to download it from the command line.  That wouldn't do, so I looked at the code underneath and saw it was just using NLTK and was able to use that to do my automatic download if needed.

### Convert message board to JSON/Dict
The structure of stats.py implied that we should pull all the data via multiple API calls, then convert it to a Dict, then convert it to json.  Converting multiple json objects to a single dict, then back to json just seemed a little silly.  So I took a rather liberal view of the instructions and added a library that allowed me to expand the API calls, ultimately giving me the entire message board in a single call, already JSON.  The only real issue with this is performance for large datasets.  Ultimately, there would be a similar problem with the multiple calls, but it could be addressed there via splitting up the calls, implementing asynchronously, etc.  If this were a production instance, I'd probably want to know more about the purpose/intent to decide the best strategy.  But with the current data/information, a single API call was the simplest/most straightforward.

### Which "Show Off" Task to Implement
The biggest piece that seemed missing from this to me was Users and Authentication, so I chose that.  It just seemed weird to have Authors, but no users.  I debated about going all out and throwing in social auth using Django-Allauth, but didn't want to have to go through and setup the various keys necessary.  Also, since the system already existed prior to having authentication, (and Django doesn't generally like you messing with the User after the fact) I decided to just use the built in authentication.  I ran into a bit of trouble with my migrations, forgetting that I couldn't have a migration just add the non-nullable foreign-keys since migrations already existed, so I had to make the painful decision to allow it to be nullable, but not blank.  It gets it close, but doesn't require me to blow out the existing migrations (though if it hadn't rolled out to production yet, that is probably what I would have done instead).  Once I got through the various interface pieces that needed to be updated, I decided to add the authentication to the API as well, which was pretty straitforward for the most part.

## What Did I Find Challenging?
The main complication I ran into was just finding a continuous block of time to complete it (it's been a hectic week).  Aside from that, there were a couple things that I hadn't done in a while, so I had to take some time to remember how they worked and any gotchas (I've spent more time working on the backend/APIs in Django apps lately and I've been using Pytest instead of the build in Django test framework).  I missed my parameterized tests!  Not having really worked with NLP libraries much meant I had to play around with them a bit before I had that working.  Factory-Boy was another library I had never really used, so when I added the Users, I needed to update all the existing tests, so I had to spend some time learning how Factory-Boy worked (their documentation isn't as good as I would have liked, but I figured it out).

## Interesting decisions
I think this was mostly covered in the design decisions.

## Additional Feedback
When I first looked at the project, I was so happy when I saw it was using Poetry.  I switched to that sometime last year and never looked back.  I was surprised to see the project still used the built in Django test framework instead of PyTest though.  I think it makes the testing in general cleaner, and easier.  Overall, this was a fun assignment.  As I mentioned before, my biggest issue was just finding a single block of uninterupted time, so I had to work on it a little bit at a time.  I'm not sure how much time I actually spent in total, but I'm sure all the context switching made it worse (which is ultimatley why I decided not to add more to the show-off section).  If time wasn't an issue, I probably would have fleshed out and refactored the tests more (and the UI).
